package service

import (
	"context"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"
	"sync"
	"time"
)

// ProcessingTask ƒë·∫°i di·ªán cho m·ªôt t√°c v·ª• x·ª≠ l√Ω
type ProcessingTask struct {
	ID       string
	Type     string
	Status   string // "pending", "running", "completed", "failed"
	Result   interface{}
	Error    error
	Progress float64 // 0-100
}

// ParallelProcessor x·ª≠ l√Ω song song c√°c t√°c v·ª•
type ParallelProcessor struct {
	tasks  map[string]*ProcessingTask
	mutex  sync.RWMutex
	ctx    context.Context
	cancel context.CancelFunc
}

// NewParallelProcessor t·∫°o processor m·ªõi
func NewParallelProcessor() *ParallelProcessor {
	ctx, cancel := context.WithCancel(context.Background())
	return &ParallelProcessor{
		tasks:  make(map[string]*ProcessingTask),
		ctx:    ctx,
		cancel: cancel,
	}
}

// AddTask th√™m t√°c v·ª• m·ªõi
func (p *ParallelProcessor) AddTask(id, taskType string) {
	p.mutex.Lock()
	defer p.mutex.Unlock()

	p.tasks[id] = &ProcessingTask{
		ID:       id,
		Type:     taskType,
		Status:   "pending",
		Progress: 0,
	}
}

// UpdateTaskProgress c·∫≠p nh·∫≠t ti·∫øn ƒë·ªô t√°c v·ª•
func (p *ParallelProcessor) UpdateTaskProgress(id string, progress float64, status string) {
	p.mutex.Lock()
	defer p.mutex.Unlock()

	if task, exists := p.tasks[id]; exists {
		task.Progress = progress
		task.Status = status
	}
}

// GetTaskStatus l·∫•y tr·∫°ng th√°i t√°c v·ª•
func (p *ParallelProcessor) GetTaskStatus(id string) (*ProcessingTask, bool) {
	p.mutex.RLock()
	defer p.mutex.RUnlock()

	task, exists := p.tasks[id]
	return task, exists
}

// GetAllTasks l·∫•y t·∫•t c·∫£ t√°c v·ª•
func (p *ParallelProcessor) GetAllTasks() map[string]*ProcessingTask {
	p.mutex.RLock()
	defer p.mutex.RUnlock()

	result := make(map[string]*ProcessingTask)
	for id, task := range p.tasks {
		result[id] = task
	}
	return result
}

// ProcessVideoParallel x·ª≠ l√Ω video song song
type ProcessVideoParallel struct {
	VideoPath        string
	AudioPath        string
	VideoDir         string
	TargetLanguage   string
	SubtitleColor    string
	SubtitleBgColor  string
	BackgroundVolume float64
	TTSVolume        float64
	SpeakingRate     float64
	VoiceName        string // Th√™m tr∆∞·ªùng ch·ªçn gi·ªçng ƒë·ªçc
	HasCustomSrt     bool
	CustomSrtPath    string
	Processor        *ParallelProcessor
	APIKey           string
	GeminiKey        string
	CacheService     *CacheService
	PricingService   *PricingService
}

// NewProcessVideoParallel t·∫°o processor m·ªõi
func NewProcessVideoParallel(videoPath, audioPath, videoDir, targetLanguage, apiKey, geminiKey string) *ProcessVideoParallel {
	return &ProcessVideoParallel{
		VideoPath:        videoPath,
		AudioPath:        audioPath,
		VideoDir:         videoDir,
		TargetLanguage:   targetLanguage,
		SubtitleColor:    "#FFFFFF",
		SubtitleBgColor:  "#808080",
		BackgroundVolume: 1.2,
		TTSVolume:        1.5,
		SpeakingRate:     1.2,
		VoiceName:        "", // S·∫Ω ƒë∆∞·ª£c set sau t·ª´ job
		Processor:        NewParallelProcessor(),
		APIKey:           apiKey,
		GeminiKey:        geminiKey,
		CacheService:     NewCacheService(),
		PricingService:   NewPricingService(),
	}
}

// ProcessParallel x·ª≠ l√Ω song song
func (p *ProcessVideoParallel) ProcessParallel() (*ProcessVideoResult, error) {
	log.Printf("üöÄ [PARALLEL PROCESSING] B·∫Øt ƒë·∫ßu parallel video processing...")
	startTime := time.Now()

	// Kh·ªüi t·∫°o c√°c t√°c v·ª•
	p.Processor.AddTask("whisper", "speech_to_text")
	p.Processor.AddTask("background", "audio_separation")

	log.Printf("üîß [PARALLEL PROCESSING] ƒê√£ kh·ªüi t·∫°o tasks: whisper + background extraction")

	// B∆∞·ªõc 1: X·ª≠ l√Ω song song Whisper v√† Background extraction
	var wg sync.WaitGroup
	var whisperResult *WhisperResult
	var backgroundResult *BackgroundResult
	var whisperErr, backgroundErr error

	log.Printf("‚ö° [PARALLEL PROCESSING] Kh·ªüi ƒë·ªông 2 goroutines ch·∫°y song song...")

	// Whisper processing
	wg.Add(1)
	go func() {
		defer wg.Done()
		log.Printf("üé§ [PARALLEL-WHISPER] Worker b·∫Øt ƒë·∫ßu x·ª≠ l√Ω Whisper...")
		p.Processor.UpdateTaskProgress("whisper", 10, "running")
		whisperResult, whisperErr = p.processWhisper()
		if whisperErr != nil {
			log.Printf("‚ùå [PARALLEL-WHISPER] Whisper failed: %v", whisperErr)
			p.Processor.UpdateTaskProgress("whisper", 0, "failed")
		} else {
			log.Printf("‚úÖ [PARALLEL-WHISPER] Whisper completed successfully")
			p.Processor.UpdateTaskProgress("whisper", 100, "completed")
		}
	}()

	// Background extraction
	wg.Add(1)
	go func() {
		defer wg.Done()
		log.Printf("üéµ [PARALLEL-BACKGROUND] Worker b·∫Øt ƒë·∫ßu x·ª≠ l√Ω background extraction...")
		p.Processor.UpdateTaskProgress("background", 10, "running")
		backgroundResult, backgroundErr = p.processBackground()
		if backgroundErr != nil {
			log.Printf("‚ùå [PARALLEL-BACKGROUND] Background extraction failed: %v", backgroundErr)
			p.Processor.UpdateTaskProgress("background", 0, "failed")
		} else {
			log.Printf("‚úÖ [PARALLEL-BACKGROUND] Background extraction completed successfully")
			p.Processor.UpdateTaskProgress("background", 100, "completed")
		}
	}()

	log.Printf("‚è≥ [PARALLEL PROCESSING] ƒêang ch·ªù 2 goroutines ho√†n th√†nh...")
	wg.Wait()
	log.Printf("üéØ [PARALLEL PROCESSING] C·∫£ 2 goroutines ƒë√£ ho√†n th√†nh!")

	// Ki·ªÉm tra l·ªói
	if whisperErr != nil {
		return nil, fmt.Errorf("whisper processing failed: %v", whisperErr)
	}
	if backgroundErr != nil {
		log.Printf("‚ö†Ô∏è [PARALLEL PROCESSING] Background extraction failed, s·ª≠ d·ª•ng fallback: %v", backgroundErr)
		// S·ª≠ d·ª•ng fallback
		backgroundResult = &BackgroundResult{
			Path: p.AudioPath, // S·ª≠ d·ª•ng audio g·ªëc
		}
	}

	log.Printf("üî§ [PARALLEL PROCESSING] B∆∞·ªõc 2: B·∫Øt ƒë·∫ßu translation (ph·ª• thu·ªôc v√†o Whisper)...")
	// B∆∞·ªõc 2: Translation (ph·ª• thu·ªôc v√†o Whisper)
	p.Processor.AddTask("translation", "srt_translation")
	p.Processor.UpdateTaskProgress("translation", 10, "running")

	translationResult, err := p.processTranslation(whisperResult)
	if err != nil {
		p.Processor.UpdateTaskProgress("translation", 0, "failed")
		return nil, fmt.Errorf("L·ªói d·ªãch thu·∫≠t: %v", err)
	}
	p.Processor.UpdateTaskProgress("translation", 100, "completed")
	log.Printf("‚úÖ [PARALLEL PROCESSING] Translation completed successfully")

	log.Printf("üéôÔ∏è [PARALLEL PROCESSING] B∆∞·ªõc 3: B·∫Øt ƒë·∫ßu TTS processing...")
	// B∆∞·ªõc 3: TTS
	p.Processor.AddTask("tts", "text_to_speech")
	p.Processor.UpdateTaskProgress("tts", 10, "running")

	ttsResult, err := p.processTTS(translationResult)
	if err != nil {
		p.Processor.UpdateTaskProgress("tts", 0, "failed")
		return nil, fmt.Errorf("L·ªói TTS: %v", err)
	}
	p.Processor.UpdateTaskProgress("tts", 100, "completed")
	log.Printf("‚úÖ [PARALLEL PROCESSING] TTS completed successfully")

	log.Printf("üé¨ [PARALLEL PROCESSING] B∆∞·ªõc 4: B·∫Øt ƒë·∫ßu video processing...")
	// B∆∞·ªõc 4: Video processing
	p.Processor.AddTask("video", "video_processing")
	p.Processor.UpdateTaskProgress("video", 10, "running")

	videoResult, err := p.processVideo(ttsResult, backgroundResult, translationResult)
	if err != nil {
		p.Processor.UpdateTaskProgress("video", 0, "failed")
		return nil, fmt.Errorf("L·ªói video processing: %v", err)
	}
	p.Processor.UpdateTaskProgress("video", 100, "completed")
	log.Printf("‚úÖ [PARALLEL PROCESSING] Video processing completed successfully")

	processingTime := time.Since(startTime)
	log.Printf("üèÅ [PARALLEL PROCESSING] T·∫•t c·∫£ parallel processing ho√†n th√†nh trong %v", processingTime)

	// Set th√¥ng tin b·ªï sung
	videoResult.OriginalSRTPath = whisperResult.SRTPath
	videoResult.Transcript = whisperResult.Transcript
	videoResult.Segments = whisperResult.Segments
	videoResult.ProcessingTime = processingTime

	return videoResult, nil
}

// WhisperResult k·∫øt qu·∫£ t·ª´ Whisper
type WhisperResult struct {
	Transcript string
	Segments   []Segment
	SRTPath    string
}

// BackgroundResult k·∫øt qu·∫£ t·ª´ background extraction
type BackgroundResult struct {
	Path string
}

// TranslationResult k·∫øt qu·∫£ t·ª´ translation
type TranslationResult struct {
	TranslatedSRTPath string
	TranslatedContent string
}

// TTSResult k·∫øt qu·∫£ t·ª´ TTS
type TTSResult struct {
	TTSPath string
}

// ProcessVideoResult k·∫øt qu·∫£ cu·ªëi c√πng
type ProcessVideoResult struct {
	FinalVideoPath    string
	BackgroundPath    string
	TTSPath           string
	OriginalSRTPath   string
	TranslatedSRTPath string
	Transcript        string
	Segments          []Segment
	ProcessingTime    time.Duration
}

// processWhisper x·ª≠ l√Ω Whisper
func (p *ProcessVideoParallel) processWhisper() (*WhisperResult, error) {
	log.Printf("Processing Whisper...")

	var transcript string
	var segments []Segment

	if p.HasCustomSrt {
		// S·ª≠ d·ª•ng custom SRT - parse file SRT ƒë·ªÉ l·∫•y segments v√† transcript
		// Parse SRT file ƒë·ªÉ l·∫•y segments
		parsedSegments, err := ParseSRTToSegments(p.CustomSrtPath)
		if err != nil {
			return nil, fmt.Errorf("failed to parse custom SRT file: %v", err)
		}

		// T·∫°o transcript t·ª´ segments
		var transcriptLines []string
		for _, segment := range parsedSegments {
			transcriptLines = append(transcriptLines, segment.Text)
		}
		transcript = strings.Join(transcriptLines, " ")
		segments = parsedSegments
	} else {
		// Ki·ªÉm tra cache tr∆∞·ªõc
		if cachedResult, err := p.CacheService.GetCachedWhisperResult(p.AudioPath); err == nil {
			log.Printf("Using cached Whisper result")
			return cachedResult, nil
		}

		// S·ª≠ d·ª•ng Whisper
		var err error
		transcript, segments, _, err = TranscribeWhisperOpenAI(p.AudioPath, p.APIKey)
		if err != nil {
			return nil, err
		}
	}

	// T·∫°o SRT file
	srtPath := filepath.Join(p.VideoDir, "original.srt")
	srtContent := createSRT(segments)
	if err := os.WriteFile(srtPath, []byte(srtContent), 0644); err != nil {
		return nil, err
	}

	result := &WhisperResult{
		Transcript: transcript,
		Segments:   segments,
		SRTPath:    srtPath,
	}

	// Cache k·∫øt qu·∫£
	if !p.HasCustomSrt {
		p.CacheService.CacheWhisperResult(p.AudioPath, result)
	}

	return result, nil
}

// processBackground x·ª≠ l√Ω background extraction
func (p *ProcessVideoParallel) processBackground() (*BackgroundResult, error) {
	log.Printf("Processing background extraction...")

	// Ki·ªÉm tra cache tr∆∞·ªõc
	if cachedPath, err := p.CacheService.GetCachedBackgroundResult(p.AudioPath); err == nil {
		log.Printf("Using cached background result")
		return &BackgroundResult{Path: cachedPath}, nil
	}

	// S·ª≠ d·ª•ng optimized background extractor
	extractor := NewOptimizedBackgroundExtractor(p.AudioPath, p.VideoDir)
	backgroundPath, err := extractor.ExtractWithFallback()
	if err != nil {
		return nil, err
	}

	// Cache k·∫øt qu·∫£
	p.CacheService.CacheBackgroundResult(p.AudioPath, backgroundPath)

	return &BackgroundResult{
		Path: backgroundPath,
	}, nil
}

// processTranslation x·ª≠ l√Ω translation
func (p *ProcessVideoParallel) processTranslation(whisperResult *WhisperResult) (*TranslationResult, error) {
	log.Printf("Processing translation...")

	if p.HasCustomSrt {
		// S·ª≠ d·ª•ng custom SRT
		return &TranslationResult{
			TranslatedSRTPath: p.CustomSrtPath,
			TranslatedContent: "", // S·∫Ω ƒë·ªçc t·ª´ file
		}, nil
	}

	// L·∫•y service_name v√† model_api_name cho nghi·ªáp v·ª• d·ªãch SRT t·ª´ b·∫£ng service_config
	serviceName, srtModelAPIName, err := p.PricingService.GetActiveServiceForType("srt_translation")
	if err != nil {
		return nil, fmt.Errorf("failed to get active SRT translation service: %v", err)
	}

	// D·ªãch SRT v·ªõi context-aware translation
	var translatedContent string
	if strings.Contains(serviceName, "gpt") {
		// Use GPT for translation with context awareness
		translatedContent, err = TranslateSRTWithContextAwareness(whisperResult.SRTPath, p.APIKey, srtModelAPIName, p.TargetLanguage)
	} else {
		// Use Gemini for translation with context awareness (default)
		translatedContent, err = TranslateSRTWithContextAwareness(whisperResult.SRTPath, p.GeminiKey, srtModelAPIName, p.TargetLanguage)
	}
	if err != nil {
		return nil, err
	}

	// L∆∞u file ƒë√£ d·ªãch
	translatedSRTPath := filepath.Join(p.VideoDir, "translated.srt")
	if err := os.WriteFile(translatedSRTPath, []byte(translatedContent), 0644); err != nil {
		return nil, err
	}

	return &TranslationResult{
		TranslatedSRTPath: translatedSRTPath,
		TranslatedContent: translatedContent,
	}, nil
}

// processTTS x·ª≠ l√Ω TTS
func (p *ProcessVideoParallel) processTTS(translationResult *TranslationResult) (*TTSResult, error) {
	log.Printf("Processing TTS...")

	// ƒê·ªçc n·ªôi dung SRT ƒë√£ d·ªãch
	content := translationResult.TranslatedContent
	if content == "" {
		// ƒê·ªçc t·ª´ file
		contentBytes, err := os.ReadFile(translationResult.TranslatedSRTPath)
		if err != nil {
			return nil, err
		}
		content = string(contentBytes)
	}

	// X√°c ƒë·ªãnh ng√¥n ng·ªØ cho TTS
	var ttsLanguage string
	if p.HasCustomSrt {
		// N·∫øu user upload SRT custom, detect ng√¥n ng·ªØ t·ª´ n·ªôi dung SRT
		ttsLanguage = DetectSRTLanguage(content)
		log.Printf("Using detected language for TTS: %s (from custom SRT)", ttsLanguage)
		log.Printf("Note: targetLanguage parameter is ignored when custom SRT is provided. Using detected language: %s", ttsLanguage)
	} else {
		// N·∫øu kh√¥ng c√≥ SRT custom, s·ª≠ d·ª•ng targetLanguage
		ttsLanguage = p.TargetLanguage
		log.Printf("Using target language for TTS: %s", ttsLanguage)
	}

	// S·ª≠ d·ª•ng Optimized TTS Service thay v√¨ TTS c≈©
	ttsPath, err := p.processTTSWithOptimizedService(content, ttsLanguage)
	if err != nil {
		return nil, err
	}

	return &TTSResult{
		TTSPath: ttsPath,
	}, nil
}

// processVideo x·ª≠ l√Ω video cu·ªëi c√πng
func (p *ProcessVideoParallel) processVideo(ttsResult *TTSResult, backgroundResult *BackgroundResult, translationResult *TranslationResult) (*ProcessVideoResult, error) {
	log.Printf("Processing final video...")

	// Merge video v·ªõi audio
	mergedPath, err := MergeVideoWithAudio(p.VideoPath, backgroundResult.Path, ttsResult.TTSPath, p.VideoDir, p.BackgroundVolume, p.TTSVolume)
	if err != nil {
		return nil, err
	}

	// Burn subtitle
	finalPath := mergedPath
	if translationResult.TranslatedSRTPath != "" {
		burnedPath, err := BurnSubtitleWithBackground(mergedPath, translationResult.TranslatedSRTPath, p.VideoDir, p.SubtitleColor, p.SubtitleBgColor)
		if err != nil {
			log.Printf("Subtitle burn failed, using merged video: %v", err)
		} else {
			finalPath = burnedPath
		}
	}

	return &ProcessVideoResult{
		FinalVideoPath:    finalPath,
		BackgroundPath:    backgroundResult.Path,
		TTSPath:           ttsResult.TTSPath,
		OriginalSRTPath:   "", // S·∫Ω ƒë∆∞·ª£c set sau
		TranslatedSRTPath: translationResult.TranslatedSRTPath,
		Transcript:        "",  // S·∫Ω ƒë∆∞·ª£c set sau
		Segments:          nil, // S·∫Ω ƒë∆∞·ª£c set sau
	}, nil
}

// processTTSWithOptimizedService x·ª≠ l√Ω TTS v·ªõi Optimized TTS Service
func (p *ProcessVideoParallel) processTTSWithOptimizedService(srtContent, targetLanguage string) (string, error) {
	log.Printf("Processing TTS with Optimized TTS Service...")

	// Kh·ªüi t·∫°o Optimized TTS Service
	ttsService, err := InitOptimizedTTSService("", 6)
	if err != nil {
		log.Printf("Failed to initialize Optimized TTS Service, falling back to old TTS: %v", err)
		// Fallback v·ªÅ TTS c≈© n·∫øu kh√¥ng th·ªÉ kh·ªüi t·∫°o service m·ªõi
		return ConvertSRTToSpeechWithLanguageAndVoice(srtContent, p.VideoDir, p.SpeakingRate, targetLanguage, p.VoiceName)
	}

	// T·∫°o job ID cho TTS processing
	jobID := fmt.Sprintf("tts_%s_%d", filepath.Base(p.VideoDir), time.Now().UnixNano())

	// T·∫°o options cho TTS
	options := TTSProcessingOptions{
		TargetLanguage:   targetLanguage,
		ServiceName:      "gpt-4o-mini", // Default service
		SubtitleColor:    p.SubtitleColor,
		SubtitleBgColor:  p.SubtitleBgColor,
		BackgroundVolume: p.BackgroundVolume,
		TTSVolume:        p.TTSVolume,
		SpeakingRate:     p.SpeakingRate,
		MaxConcurrent:    6,
		UserID:           0,           // Kh√¥ng c√≥ user ID trong context n√†y
		VoiceName:        p.VoiceName, // Th√™m voice selection
	}

	// X·ª≠ l√Ω TTS v·ªõi concurrent processing
	audioPath, err := ttsService.ProcessSRTConcurrent(srtContent, p.VideoDir, options, jobID)
	if err != nil {
		log.Printf("Optimized TTS failed, falling back to old TTS: %v", err)
		// Fallback v·ªÅ TTS c≈© n·∫øu service m·ªõi th·∫•t b·∫°i
		return ConvertSRTToSpeechWithLanguageAndVoice(srtContent, p.VideoDir, p.SpeakingRate, targetLanguage, p.VoiceName)
	}

	log.Printf("Optimized TTS completed successfully: %s", audioPath)
	return audioPath, nil
}

// Helper functions
func createSRT(segments []Segment) string {
	var result strings.Builder
	for i, segment := range segments {
		result.WriteString(fmt.Sprintf("%d\n", i+1))
		result.WriteString(fmt.Sprintf("%s --> %s\n", formatTimeForSRT(segment.Start), formatTimeForSRT(segment.End)))
		result.WriteString(segment.Text + "\n\n")
	}
	return result.String()
}

func formatTimeForSRT(seconds float64) string {
	hours := int(seconds) / 3600
	minutes := int(seconds) % 3600 / 60
	secs := int(seconds) % 60
	millisecs := int((seconds - float64(int(seconds))) * 1000)
	return fmt.Sprintf("%02d:%02d:%02d,%03d", hours, minutes, secs, millisecs)
}
